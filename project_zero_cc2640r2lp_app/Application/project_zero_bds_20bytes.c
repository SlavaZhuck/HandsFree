/*
 * Filename: project_zero.c
 *
 * Description: This is the simple_central example modified to receive
 * data over BLE at a high throughput.
 *
 *
 * Copyright (C) 2015-2017 Texas Instruments Incorporated - http://www.ti.com/
 *
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 Generated by:
 BDS version: 1.1.3139.0
 Plugin:      Texas Instruments BLE SDK GATT Server plugin 1.0.9
 Time:        Fri Sep 15 2017 01:07:25 GMT+07:00
 *****************************************************************************/

/*
 * INCLUDES
 */
#include <string.h>
#include <math.h>
#define xdc_runtime_Log_DISABLE_ALL 1  // Add to disable logs from this file

#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/knl/Event.h>
#include <ti/sysbios/knl/Queue.h>
#include <ti/sysbios/knl/Clock.h>

#include <ti/drivers/PIN.h>
#include <ti/display/Display.h>

#include <xdc/runtime/Log.h>
#include <xdc/runtime/Diags.h>


/* This Header file contains all BLE API and icall structure definition */
#include "icall_ble_api.h"
#include <icall.h>

#include <osal_snv.h>
#include <peripheral.h>
#include <devinfoservice.h>

#include "util.h"

#include "Board.h"
#include "Uart_Parser.h"
#include "project_zero.h"
#include "GeneralDef.h"
// Bluetooth Developer Studio services
#include "vogatt.h"

#include <ti/drivers/timer/GPTimerCC26XX.h>
#include <ti/drivers/crypto/CryptoCC26XX.h>

#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Mailbox.h>

#include <xdc/runtime/Memory.h>
#include <xdc/runtime/Error.h>

#include "codec/SitADPCM.h"

#include <driverlib/vims.h>
#include <driverlib/flash.h>
#include <ti/sysbios/family/arm/m3/Hwi.h>


#include "I2S/I2SCC26XX.h"

#include <osal/src/inc/osal_snv.h>
#include "bcomdef.h"

#include "driverlib/aon_batmon.h"
#include "Uart_commands.h"
#include "max9860_i2c.h"
#include "Interpolation.h"

#ifdef  LPF
  #include "../LPF/LPF.h"                       /* Model's header file */
  #include "../LPF/rtwtypes.h"
#endif



/*********************************************************************
 * CONSTANTS
 */
// Advertising interval when device is discoverable (units of 625us, 160=100ms)
#define DEFAULT_ADVERTISING_INTERVAL          160

// Limited discoverable mode advertises for 30.72s, and then stops
// General discoverable mode advertises indefinitely
#define DEFAULT_DISCOVERABLE_MODE             GAP_ADTYPE_FLAGS_GENERAL

// Default pass-code used for pairing.
#define DEFAULT_PASSCODE                      0

// Task configuration
#define PRZ_TASK_PRIORITY                     1

#ifndef PRZ_TASK_STACK_SIZE
#define PRZ_TASK_STACK_SIZE                   1100
#endif

// Internal Events for RTOS application
#define PRZ_ICALL_EVT                         ICALL_MSG_EVENT_ID  // Event_Id_31
#define PRZ_QUEUE_EVT                         UTIL_QUEUE_EVENT_ID // Event_Id_30
#define PRZ_STATE_CHANGE_EVT                  Event_Id_00
#define PRZ_CHAR_CHANGE_EVT                   Event_Id_01
#define PRZ_PERIODIC_EVT                      Event_Id_02
#define PRZ_APP_MSG_EVT                       Event_Id_03
#define PRZ_CONN_EVT_END_EVT                  Event_Id_30

#define PRZ_ALL_EVENTS                       (PRZ_ICALL_EVT        | \
                                              PRZ_QUEUE_EVT        | \
                                              PRZ_STATE_CHANGE_EVT | \
                                              PRZ_CHAR_CHANGE_EVT  | \
                                              PRZ_PERIODIC_EVT     | \
                                              PRZ_APP_MSG_EVT      | \
                                              PRZ_CONN_EVT_END_EVT)

/****************************** User's defines **********************************/
#define I2S_MEM_BASE                        (GPRAM_BASE + FlashSectorSizeGet())
#define AUDIO_DUPLEX_STREAM_TYPE_NONE       AUDIO_DUPLEX_CMD_STOP
#define AUDIO_DUPLEX_STREAM_TYPE_ADPCM      AUDIO_DUPLEX_CMD_START
#ifdef DOUBLE_DATA_RATE
    #define I2S_SAMP_PER_FRAME                  160
#else
    #define I2S_SAMP_PER_FRAME                  80
#endif
#define NUM_OF_CHANNELS                     2
#define I2S_BUF                             sizeof(int16_t) * (I2S_SAMP_PER_FRAME *   \
                                            I2SCC26XX_QUEUE_SIZE * NUM_OF_CHANNELS)

#define EXTRAPOLATE_FACTOR                  4
//#define ADCBUFSIZE                          I2S_SAMP_PER_FRAME*EXTRAPOLATE_FACTOR//80
//#define SAMPFREQ                            8000*EXTRAPOLATE_FACTOR

#define KEY_SNV_ID                          BLE_NVID_CUST_START
#define KEY_SIZE                            16
#define INIT_VOL_ADDR                       BLE_NVID_CUST_START+1

#define TMR_PERIOD                          96000000UL
#define LOW_STATE_TIME                      ((TMR_PERIOD / 10) * 9)
#define HIGH_STATE_TIME                     (TMR_PERIOD - LOW_STATE_TIME)

#define SAMP_TIME                           479999UL

#define BAT_LOW_VOLTAGE                     3000

#define TIMEOUT                             2000

/*********************************************************************
 * TYPEDEFS
 */
// Types of messages that can be sent to the user application task from other
// tasks or interrupts. Note: Messages from BLE Stack are sent differently.
static Mailbox_Handle mailbox;
static uint8_t mailpost_usage = 0;

#define MAILBOX_DEPTH 10
#define MIN_MAILBOX_USAGE 1

// Struct for messages sent to the application task
typedef struct
{
  Queue_Elem       _elem;
  app_msg_types_t  type;
  uint8_t          pdu[];
} app_msg_t;

// Struct for messages about characteristic data
typedef struct
{
  uint16_t svcUUID; // UUID of the service
  uint16_t dataLen; //
  uint8_t  paramID; // Index of the characteristic
  uint8_t  data[];  // Flexible array member, extended to malloc - sizeof(.)
} char_data_t;

// Struct for message about sending/requesting passcode from peer.
typedef struct
{
  uint16_t connHandle;
  uint8_t  uiInputs;
  uint8_t  uiOutputs;
  uint32   numComparison;
} passcode_req_t;

// Struct for message about button state
typedef struct
{
  PIN_Id   pinId;
  uint8_t  state;
} button_state_t;


/*********************************************************************
 * LOCAL VARIABLES
 */

// Entity ID globally used to check for source and/or destination of messages
static ICall_EntityID selfEntity;

// Sync handle globally used to post events to the application thread
static ICall_SyncHandle syncEvent;

// Queue object used for application messages.
static Queue_Struct applicationMsgQ;
static Queue_Handle hApplicationMsgQ;

// Clock structs for periodic notification example
static Clock_Struct v_STREAM_OUTPUT_clock;

// Task configuration
Task_Struct przTask;
Char przTaskStack[PRZ_TASK_STACK_SIZE];

// GAP - SCAN RSP data (max size = 31 bytes)
static uint8_t scanRspData[] =
{
  // No scan response data provided.
  0x00 // Placeholder to keep the compiler happy.
};

// GAP - Advertisement data (max size = 31 bytes, though this is
// best kept short to conserve power while advertisting)
static uint8_t advertData[] =
{
  // Flags; this sets the device to use limited discoverable
  // mode (advertises for 30 seconds at a time) or general
  // discoverable mode (advertises indefinitely), depending
  // on the DEFAULT_DISCOVERY_MODE define.
  0x02,   // length of this data
  GAP_ADTYPE_FLAGS,
  DEFAULT_DISCOVERABLE_MODE | GAP_ADTYPE_FLAGS_BREDR_NOT_SUPPORTED,

  // complete name
  14,
  GAP_ADTYPE_LOCAL_NAME_COMPLETE,
  'C', 'I', 'T', ' ', 'H', 'a', 'n', 'd', 's', 'F', 'r', 'e', 'e','2',

};

// GAP GATT Attributes
static uint8_t attDeviceName[GAP_DEVICE_NAME_LEN] = "CIT HandsFree2";

// Globals used for ATT Response retransmission
static gattMsgEvent_t *pAttRsp = NULL;
static uint8_t rspTxRetry = 0;

// Global display handle
Display_Handle dispHandle;

static Bool buttonVol_UP_pressed = false;
static Bool buttonVol_DOWN_pressed = false;
/*
 * Application button pin configuration table:
 *   - Buttons interrupts are configured to trigger on falling edge.
 */
PIN_Config buttonPinTable[] = {
    CC2640R2_LAUNCHXL_PIN_BTN1  | PIN_INPUT_EN | PIN_PULLUP | PIN_IRQ_NEGEDGE,
    CC2640R2_LAUNCHXL_PIN_BTN2  | PIN_INPUT_EN | PIN_PULLUP | PIN_IRQ_NEGEDGE,
    PIN_TERMINATE
};

// Global pin's handle ans status
PIN_Config ledPinTable[] = {
  Board_RLED | PIN_GPIO_OUTPUT_EN | PIN_GPIO_LOW | PIN_PUSHPULL | PIN_DRVSTR_MAX,
  Board_GLED | PIN_GPIO_OUTPUT_EN | PIN_GPIO_LOW | PIN_PUSHPULL | PIN_DRVSTR_MAX,
  PIN_TERMINATE
};

/* Pin driver handles */
static PIN_Handle buttonPinHandle;

/* Global memory storage for a PIN_Config table */
static PIN_State buttonPinState;

/************************************************ USER'S FUNCTIONS ****************************************/
static void bufRdy_callback(I2SCC26XX_Handle handle, I2SCC26XX_StreamNotification *pStreamNotification);

static void AudioDuplex_disableCache();
static void AudioDuplex_enableCache();


void buttonCallbackFxn(PIN_Handle handle, PIN_Id pinId);
void button_processing (void);


// Voice handle functions
static void voice_hdl_init(void);
static void blink_timer_callback(GPTimerCC26XX_Handle handle, GPTimerCC26XX_IntMask interruptMask);
static void samp_timer_callback(GPTimerCC26XX_Handle handle, GPTimerCC26XX_IntMask interruptMask);
static void start_voice_handle(void);
static void stop_voice_handle(void);
static void pdm_samp_hdl(void);

static void encrypt_packet(uint8_t *packet);
static void decrypt_packet(uint8_t *packet);

uint8_t write_aes_key(uint8_t *key);
uint8_t read_aes_key(uint8_t *key);

uint16_t get_bat_voltage(void);

/*********************************** USER'S VARIABLES ****************************************************/


static PIN_Handle ledPinHandle;
static PIN_State ledPinState;

static GPTimerCC26XX_Params tim_params;
static GPTimerCC26XX_Handle blink_tim_hdl = NULL;
//GPTimerCC26XX_Handle system_time = NULL;
static GPTimerCC26XX_Handle samp_tim_hdl = NULL;

static I2SCC26XX_StreamNotification i2sStream;
static I2SCC26XX_BufferRelease bufferRelease;
static I2SCC26XX_StreamNotification i2sStream;
static I2SCC26XX_BufferRequest bufferRequest;
static I2SCC26XX_Handle i2sHandle = (I2SCC26XX_Handle)&(I2SCC26XX_config);
static I2SCC26XX_Params i2sParams =
{
    .requestMode            = I2SCC26XX_CALLBACK_MODE,//I2SCC26XX_CALLBACK_MODE,
    .ui32requestTimeout     = BIOS_WAIT_FOREVER,
    .callbackFxn            = bufRdy_callback,//bufRdy_callback,
    .blockSize              = 0,
    .pvContBuffer           = NULL,
    .ui32conBufTotalSize    = 0,
    .pvContMgtBuffer        = NULL,
    .ui32conMgtBufTotalSize = 0,
    .currentStream          = &i2sStream
};

static uint16_t i2c_read_delay = 0;
 int16_t raw_data_send[I2S_SAMP_PER_FRAME];
 uint8_t packet_data[V_STREAM_INPUT_LEN];

 static unsigned char pdm_val = 1;
 static unsigned char button_val = 1;
 static unsigned char vol_val = 1;
 static unsigned char i2c_val = 1;

static uint8_t current_volume;

#define ADCBUFSIZE      1
#define SAMPFREQ        1000000

 ADCBuf_Handle adc_hdl;
static ADCBuf_Params adc_params;
 ADCBuf_Conversion adc_conversion;
int16_t adc_data[ADCBUFSIZE];
static int16_t samp_buf1[ADCBUFSIZE];
static int16_t samp_buf2[ADCBUFSIZE];

void adc_callback(ADCBuf_Handle handle, ADCBuf_Conversion *conversion,
                  void *completedADCBuffer, uint32_t completedChannel);

static struct ADPCMstate encoder_adpcm, decoder_adpcm;
static int stream_on = 0;

static int16_t *audio_decoded = NULL;
static uint8_t *i2sContMgtBuffer = NULL;

//static int16_t mic_data[I2S_SAMP_PER_FRAME];
static int16_t mic_data_1ch[I2S_SAMP_PER_FRAME];
//static int16_t mic_data_2ch[I2S_SAMP_PER_FRAME];

static uint32_t timer_count = 0;
static uint32_t task_count = 0;

bool gotBufferInOut = false;

bool gotBufferIn = false;
bool gotBufferOut = false;

static CryptoCC26XX_Handle crypto_hdl;
static CryptoCC26XX_Params crypto_params;
uint8_t key[] = {0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
                        0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C};
static int32_t key_index = 0;
static int32_t status;
static CryptoCC26XX_AESECB_Transaction trans;

static GPTimerCC26XX_Value load_val[2] = {LOW_STATE_TIME, HIGH_STATE_TIME};

uint32_t packet_counter = 0;
UART_Handle uart;
static UART_Params uartParams;
unsigned char key_val;

#ifdef UART_DEBUG
  #define UART_BAUD_RATE 921600
  int16_t uart_data_send[80+1];

#endif
#ifdef DOUBLE_DATA_RATE
  int16_t temp_output[I2S_SAMP_PER_FRAME/2];
  int16_t extrapolate_buf[I2S_SAMP_PER_FRAME/2];
#endif
#ifndef UART_DEBUG
  #define UART_BAUD_RATE 115200
#endif

#define NOISE_POWER 30000
#define SOUND_DELAY 25

  uint64_t channel_power = 0;
  bool sound_appeared = 0;
  uint32_t sound_timestamp = 0;

/*********************************************************************
 * LOCAL FUNCTIONS
 */

static void ProjectZero_init( void );
static void ProjectZero_taskFxn(UArg a0, UArg a1);

static void user_processApplicationMessage(app_msg_t *pMsg);
static uint8_t ProjectZero_processStackMsg(ICall_Hdr *pMsg);
static uint8_t ProjectZero_processGATTMsg(gattMsgEvent_t *pMsg);

static void ProjectZero_sendAttRsp(void);
static uint8_t ProjectZero_processGATTMsg(gattMsgEvent_t *pMsg);
static void ProjectZero_freeAttRsp(uint8_t status);

static void user_processGapStateChangeEvt(gaprole_States_t newState);
static void user_gapStateChangeCB(gaprole_States_t newState);
static void user_gapBondMgr_passcodeCB(uint8_t *deviceAddr, uint16_t connHandle,
                                       uint8_t uiInputs, uint8_t uiOutputs, uint32 numComparison);
static void user_gapBondMgr_pairStateCB(uint16_t connHandle, uint8_t state,
                                        uint8_t status);


// Generic callback handlers for value changes in services.
static void user_service_ValueChangeCB( uint16_t connHandle, uint16_t svcUuid, uint8_t paramID, uint8_t *pValue, uint16_t len );
static void user_service_CfgChangeCB( uint16_t connHandle, uint16_t svcUuid, uint8_t paramID, uint8_t *pValue, uint16_t len );

// Task context handlers for generated services.
static void user_Vogatt_ValueChangeHandler(char_data_t *pCharData);
static void user_Vogatt_CfgChangeHandler(char_data_t *pCharData);

// Task handler for sending notifications.
static void user_updateCharVal(char_data_t *pCharData);

// Utility functions
void user_enqueueRawAppMsg(app_msg_types_t appMsgType, uint8_t *pData, uint16_t len );
static void user_enqueueCharDataMsg( app_msg_types_t appMsgType, uint16_t connHandle,
                                       uint16_t serviceUUID, uint8_t paramID,
                                       uint8_t *pValue, uint16_t len );

static char *Util_convertArrayToHexString(uint8_t const *src, uint8_t src_len,
                                          uint8_t *dst, uint8_t dst_len);

/*********************************************************************
 * PROFILE CALLBACKS
 */

// GAP Role Callbacks
static gapRolesCBs_t user_gapRoleCBs =
{
  user_gapStateChangeCB     // Profile State Change Callbacks
};

// GAP Bond Manager Callbacks
static gapBondCBs_t user_bondMgrCBs =
{
  user_gapBondMgr_passcodeCB, // Passcode callback
  user_gapBondMgr_pairStateCB // Pairing / Bonding state Callback
};

/*
 * Callbacks in the user application for events originating from BLE services.
 */
// Service callback structure for registering our handlers with the service
// VoGATT callback handler.
// The type VoGATTCBs_t is defined in VoGATT.h
static VogattCBs_t user_VoGATTCBs =
{
  .pfnChangeCb    = user_service_ValueChangeCB, // Characteristic value change callback handler
  .pfnCfgChangeCb = user_service_CfgChangeCB, // Noti/ind configuration callback handler
};

/*********************************************************************
 * PUBLIC FUNCTIONS
 */

/*
 * @brief   Task creation function for the user task.
 *
 * @param   None.
 *
 * @return  None.
 */
void ProjectZero_createTask(void)
{
  Task_Params taskParams;

  // Configure task
  Task_Params_init(&taskParams);
  taskParams.stack = przTaskStack;
  taskParams.stackSize = PRZ_TASK_STACK_SIZE;
  taskParams.priority = PRZ_TASK_PRIORITY;

  Task_construct(&przTask, ProjectZero_taskFxn, &taskParams, NULL);
}

uint8_t macAddress[6];
#define MAX_NUM_RX_BYTES    100   // Maximum RX bytes to receive in one go
#define MAX_NUM_TX_BYTES    100   // Maximum TX bytes to send in one go
#define WANTED_RX_BYTES    1   // Maximum TX bytes to send in one go
static uint32_t wantedRxBytes = WANTED_RX_BYTES;            // Number of bytes received so far
static uint8_t rxBuf[MAX_NUM_RX_BYTES];   // Receive buffer
//static uint8_t txBuf[MAX_NUM_TX_BYTES];   // Transmit buffer
// Callback function

extern Serial_Data_Packet Tx_Data;
extern Serial_Data_Packet Rx_Data;
//static unsigned char test_CRC[262] ;


static void writeCallback(UART_Handle handle_uart, void *rxBuf, size_t size)
{
//SPPBLEServer_enqueueUARTMsg(SBC_UART_CHANGE_EVT,rxBuf,size);
}

static void readCallback(UART_Handle handle, void *rxBuf, size_t size)
{
 //   memset(&test_CRC,0,sizeof(test_CRC));

    OnRxByte(((unsigned char*)rxBuf)[0]);
    if(PackProcessing()){

    }

    wantedRxBytes = 1;
    UART_read(handle, rxBuf, wantedRxBytes);
}

/*
 * @brief   Called before the task loop and contains application-specific
 *          initialization of the BLE stack, hardware setup, power-state
 *          notification if used, and BLE profile/service initialization.
 *
 * @param   None.
 *
 * @return  None.
 */


static void ProjectZero_init(void)
{
    LPF_initialize();
    uint_least16_t hwiKey = Hwi_disable();

    UART_init();
    parser_init();
    voice_hdl_init();

   // UartLog_init(UART_open(Board_UART0, NULL));
    /* Create a UART with data processing off. */
    UART_Params_init(&uartParams);
    uartParams.writeDataMode    = UART_DATA_BINARY;
    uartParams.readDataMode     = UART_DATA_BINARY;
    uartParams.readMode         = UART_MODE_CALLBACK;
    uartParams.writeMode        = UART_MODE_CALLBACK;
    //uartParams.writeTimeout      = 0; //UART_WAIT_FOREVER
    uartParams.readCallback     = readCallback;
    uartParams.writeCallback    = writeCallback;
    uartParams.readReturnMode   = UART_RETURN_FULL;
    uartParams.readEcho         = UART_ECHO_OFF;
    uartParams.baudRate         = UART_BAUD_RATE;

    uart = UART_open(Board_UART0, &uartParams);
    if (uart == NULL) {
        /* UART_open() failed */
        while (1);
    }

    uint64_t temp = *((uint64_t *)(0x500012E8)) & 0xFFFFFFFFFFFFFF;
    for(uint8_t i = 0 ; i < 6 ; i++){
        macAddress[i]=*(((uint8_t *)&temp)+i);
    }
    //macAddress = *((uint64_t *)(0x500012E8)) & 0xFFFFFFFFFFFFFF;

    UART_write(uart, macAddress, sizeof(macAddress));
    int rxBytes = UART_read(uart, rxBuf, wantedRxBytes);

    Hwi_restore(hwiKey);
  // ******************************************************************
  // NO STACK API CALLS CAN OCCUR BEFORE THIS CALL TO ICall_registerApp
  // ******************************************************************
  // Register the current thread as an ICall dispatcher application
  // so that the application can send and receive messages via ICall to Stack.
  ICall_registerApp(&selfEntity, &syncEvent);

  // Open display. By default this is disabled via the predefined symbol Display_DISABLE_ALL.
  dispHandle = Display_open(Display_Type_LCD, NULL);

  // Initialize queue for application messages.
  // Note: Used to transfer control to application thread from e.g. interrupts.
  Queue_construct(&applicationMsgQ, NULL);
  hApplicationMsgQ = Queue_handle(&applicationMsgQ);

  // ******************************************************************
  // Hardware initialization
  // ******************************************************************
  ledPinHandle = PIN_open(&ledPinState, ledPinTable);
  if(!ledPinHandle)
  {
     Task_exit();
  }

  PIN_setOutputValue(ledPinHandle, Board_GLED, 1);

  // ******************************************************************
  // BLE Stack initialization
  // ******************************************************************

  // Setup the GAP Peripheral Role Profile
  uint8_t initialAdvertEnable = TRUE;  // Advertise on power-up

  // By setting this to zero, the device will go into the waiting state after
  // being discoverable. Otherwise wait this long [ms] before advertising again.
  uint16_t advertOffTime = 5000; // miliseconds

  // Set advertisement enabled.
  GAPRole_SetParameter(GAPROLE_ADVERT_ENABLED, sizeof(uint8_t),
                       &initialAdvertEnable);

  // Configure the wait-time before restarting advertisement automatically
  GAPRole_SetParameter(GAPROLE_ADVERT_OFF_TIME, sizeof(uint16_t),
                       &advertOffTime);

  // Initialize Scan Response data
  GAPRole_SetParameter(GAPROLE_SCAN_RSP_DATA, sizeof(scanRspData), scanRspData);

  // Initialize Advertisement data
  GAPRole_SetParameter(GAPROLE_ADVERT_DATA, sizeof(advertData), advertData);

  // Set advertising interval
  uint16_t advInt = DEFAULT_ADVERTISING_INTERVAL;

  GAP_SetParamValue(TGAP_LIM_DISC_ADV_INT_MIN, advInt);
  GAP_SetParamValue(TGAP_LIM_DISC_ADV_INT_MAX, advInt);
  GAP_SetParamValue(TGAP_GEN_DISC_ADV_INT_MIN, advInt);
  GAP_SetParamValue(TGAP_GEN_DISC_ADV_INT_MAX, advInt);

  // Set duration of advertisement before stopping in Limited adv mode.
  GAP_SetParamValue(TGAP_LIM_ADV_TIMEOUT, 30); // Seconds

  // ******************************************************************
  // BLE Bond Manager initialization
  // ******************************************************************
  uint32_t passkey = DEFAULT_PASSCODE;
  uint8_t pairMode = GAPBOND_PAIRING_MODE_WAIT_FOR_REQ;
  uint8_t mitm = TRUE;
  uint8_t ioCap = GAPBOND_IO_CAP_DISPLAY_ONLY;
  uint8_t bonding = TRUE;

  GAPBondMgr_SetParameter(GAPBOND_DEFAULT_PASSCODE, sizeof(uint32_t),
                          &passkey);
  GAPBondMgr_SetParameter(GAPBOND_PAIRING_MODE, sizeof(uint8_t), &pairMode);
  GAPBondMgr_SetParameter(GAPBOND_MITM_PROTECTION, sizeof(uint8_t), &mitm);
  GAPBondMgr_SetParameter(GAPBOND_IO_CAPABILITIES, sizeof(uint8_t), &ioCap);
  GAPBondMgr_SetParameter(GAPBOND_BONDING_ENABLED, sizeof(uint8_t), &bonding);

  // ******************************************************************
  // BLE Service initialization
  // ******************************************************************

  // Add services to GATT server
  GGS_AddService(GATT_ALL_SERVICES);           // GAP
  GATTServApp_AddService(GATT_ALL_SERVICES);   // GATT attributes
  DevInfo_AddService();                        // Device Information Service

  // Set the device name characteristic in the GAP Profile
  GGS_SetParameter(GGS_DEVICE_NAME_ATT, GAP_DEVICE_NAME_LEN, attDeviceName);

// Add services to GATT server and give ID of this task for Indication acks.
  Vogatt_AddService( selfEntity );

  // Register callbacks with the generated services that
  // can generate events (writes received) to the application
  Vogatt_RegisterAppCBs( &user_VoGATTCBs );
  // Placeholder variable for characteristic intialization
  uint8_t someVal[20] = {0};

  // Initalization of characteristics in VoGATT that can provide data
  // to a peer device over the air.
  Vogatt_SetParameter(V_STREAM_OUTPUT_ID, V_STREAM_OUTPUT_LEN, &someVal);

  // Start the stack in Peripheral mode.
  VOID GAPRole_StartDevice(&user_gapRoleCBs);

  // Start Bond Manager
  VOID GAPBondMgr_Register(&user_bondMgrCBs);

  // Register with GAP for HCI/Host messages
  GAP_RegisterForMsgs(selfEntity);

  // Register for GATT local events and ATT Responses pending for transmission
  GATT_RegisterForMsgs(selfEntity);

  PIN_setOutputValue(ledPinHandle, Board_GLED, 0);

  HCI_EXT_SetTxPowerCmd(HCI_EXT_TX_POWER_0_DBM);//HCI_EXT_TX_POWER_MINUS_21_DBM HCI_EXT_TX_POWER_5_DBM
  user_enqueueRawAppMsg(APP_MSG_Read_key, &key_val, 1);
  mailbox = Mailbox_create(sizeof(packet_data), MAILBOX_DEPTH, NULL, NULL);
  if (mailbox == NULL) {
      while (1);
  }
}


/*
 * @brief   Application task entry point.
 *
 *          Invoked by TI-RTOS when BIOS_start is called. Calls an init function
 *          and enters an infinite loop waiting for messages.
 *
 *          Messages can be either directly from the BLE stack or from user code
 *          like Hardware Interrupt (Hwi) or a callback function.
 *
 *          The reason for sending messages to this task from e.g. Hwi's is that
 *          some RTOS and Stack APIs are not available in callbacks and so the
 *          actions that may need to be taken is dispatched to this Task.
 *
 * @param   a0, a1 - not used.
 *
 * @return  None.
 */
static void ProjectZero_taskFxn(UArg a0, UArg a1)
{
  // Initialize application
  ProjectZero_init();

  // Application main loop
  for (;;)
  {
    uint32_t events;

    // Waits for an event to be posted associated with the calling thread.
    // Note that an event associated with a thread is posted when a
    // message is queued to the message receive queue of the thread
    events = Event_pend(syncEvent, Event_Id_NONE, PRZ_ALL_EVENTS,
                        ICALL_TIMEOUT_FOREVER);

    if (events)
    {
      ICall_EntityID dest;
      ICall_ServiceEnum src;
      ICall_HciExtEvt *pMsg = NULL;

      // Check if we got a signal because of a stack message
      if (ICall_fetchServiceMsg(&src, &dest,
                                (void **)&pMsg) == ICALL_ERRNO_SUCCESS)
      {
        uint8 safeToDealloc = TRUE;

        if ((src == ICALL_SERVICE_CLASS_BLE) && (dest == selfEntity))
        {
          ICall_Stack_Event *pEvt = (ICall_Stack_Event *)pMsg;

          // Check for event flags received (event signature 0xffff)
          if (pEvt->signature == 0xffff)
          {
            // Event received when a connection event is completed
            if (pEvt->event_flag & PRZ_CONN_EVT_END_EVT)
            {
              // Try to retransmit pending ATT Response (if any)
              ProjectZero_sendAttRsp();
            }
          }
          else // It's a message from the stack and not an event.
          {
            // Process inter-task message
            safeToDealloc = ProjectZero_processStackMsg((ICall_Hdr *)pMsg);
          }
        }

        if (pMsg && safeToDealloc)
        {
          ICall_freeMsg(pMsg);
        }
      }

      // Process messages sent from another task or another context.
      while (!Queue_empty(hApplicationMsgQ))
      {
        app_msg_t *pMsg = Queue_dequeue(hApplicationMsgQ);

        // Process application-layer message probably sent from ourselves.
        user_processApplicationMessage(pMsg);

        // Free the received message.
        ICall_free(pMsg);
      }

    }
  }
}

/*
 * @brief   Handle application messages
 *
 *          These are messages not from the BLE stack, but from the
 *          application itself.
 *
 *          For example, in a Software Interrupt (Swi) it is not possible to
 *          call any BLE APIs, so instead the Swi function must send a message
 *          to the application Task for processing in Task context.
 *
 * @param   pMsg  Pointer to the message of type app_msg_t.
 *
 * @return  None.
 */

#ifdef LPF
void rt_OneStep(void);

void rt_OneStep(void)
  {
    static boolean_T OverrunFlag = false;

    /* Disable interrupts here */

    /* Check for overrun */
    if (OverrunFlag) {
      return;
    }

    OverrunFlag = true;

    /* Save FPU context here (if necessary) */
    /* Re-enable timer or interrupt here */
    /* Set model inputs here */

    /* Step the model */
    LPF_step();

    /* Get model outputs here */

    /* Indicate task complete */
    OverrunFlag = false;

    /* Disable interrupts here */
    /* Restore FPU context here (if necessary) */
    /* Enable interrupts here */
  }
#endif

static void user_processApplicationMessage(app_msg_t *pMsg)
{
    char_data_t *pCharData = (char_data_t *)pMsg->pdu;


    switch (pMsg->type)
    {
        case APP_MSG_SERVICE_WRITE: /* Message about received value write */
            /* Call different handler per service */
            switch(pCharData->svcUUID) {
                case VOGATT_SERV_UUID:
                  user_Vogatt_ValueChangeHandler(pCharData);
                break;
            }
        break;

        case APP_MSG_SERVICE_CFG: /* Message about received CCCD write */
            /* Call different handler per service */
            switch(pCharData->svcUUID) {
                case VOGATT_SERV_UUID:
                    user_Vogatt_CfgChangeHandler(pCharData);
                break;
            }
        break;

        case APP_MSG_UPDATE_CHARVAL: /* Message to self from to update a value */
            user_updateCharVal(pCharData);
        break;


        case APP_MSG_GAP_STATE_CHANGE: /* Message that GAP state changed  */
            user_processGapStateChangeEvt( *(gaprole_States_t *)pMsg->pdu );
        break;

        case APP_MSG_SEND_PASSCODE: /* Message about pairing PIN request */
        {
            passcode_req_t *pReq = (passcode_req_t *)pMsg->pdu;
            // Send passcode response.
            GAPBondMgr_PasscodeRsp(pReq->connHandle, SUCCESS, DEFAULT_PASSCODE);
        }
        break;

        case APP_MSG_GET_VOICE_SAMP:
            task_count++;
            bufferRequest.buffersRequested = I2SCC26XX_BUFFER_IN;
            I2SCC26XX_requestBuffer(i2sHandle, &bufferRequest);
            if (gotBufferIn)
            {
                memcpy(mic_data_1ch, bufferRequest.bufferIn, sizeof(mic_data_1ch));
                bufferRelease.bufferHandleOut = NULL;
                bufferRelease.bufferHandleIn = bufferRequest.bufferHandleIn;
                I2SCC26XX_releaseBuffer(i2sHandle, &bufferRelease);
                gotBufferIn = 0;
                i2c_read_delay++;
            }

//  int16_t temp_output[I2S_SAMP_PER_FRAME/2];
//  int16_t extrapolate_buf[I2S_SAMP_PER_FRAME];
#ifdef DOUBLE_DATA_RATE

            uint16_t j = 0;


            for(uint8_t i = 0 ; i < I2S_SAMP_PER_FRAME; i+=2)
            {
                temp_output[i/2] = (mic_data_1ch[i]+mic_data_1ch[i+1])/2;
                j++;
            }



            memset(mic_data_1ch, 0x0, sizeof(mic_data_1ch));


            for(uint8_t i = 0 ; i < I2S_SAMP_PER_FRAME ; i+=2)
            {
                mic_data_1ch[i] = temp_output[i/2];
            }
            for(uint8_t i = 1 ; i < I2S_SAMP_PER_FRAME ; i+=2)
            {
                if(i == I2S_SAMP_PER_FRAME-1)
                {
                    mic_data_1ch[i] = mic_data_1ch[i-1];
                }
                else
                {
                    mic_data_1ch[i] = (mic_data_1ch[i-1]+mic_data_1ch[i+1])/2;
                }
            }

//            for(uint8_t i = 0 ; i < I2S_SAMP_PER_FRAME/2; i++)
//            {
//                extrapolate_buf[i] = i;
//            }
//            for(uint8_t i = 0 ; i < I2S_SAMP_PER_FRAME ; i+=2)
//            {
//                mic_data_1ch[i] = temp_output[i/2];
//            }
//
//            for(uint8_t i = 1 ; i < I2S_SAMP_PER_FRAME ; i+=2)
//            {
//                if(i == I2S_SAMP_PER_FRAME-1)
//                {
//                    mic_data_1ch[i] = mic_data_1ch[i-1];
//                }
//                else
//                {
//                    mic_data_1ch[i] = InterpolateLagrangePolynomial(((float)i)/2.0f, extrapolate_buf, temp_output, I2S_SAMP_PER_FRAME/2);
//                }
//            }

#endif
            /*
            uint8_t encode_buf[V_STREAM_OUTPUT_LEN];
            ADPCMEncoderBuf2(mic_data_1ch, (char*)(encode_buf), &encoder_adpcm);


            ///////////////////////////////////////////////////////////////////////////////////////
            //compressing start
//            uint8_t encode_buf[V_STREAM_OUTPUT_LEN];
            encode_buf[V_STREAM_OUTPUT_SOUND_LEN] = encoder_adpcm.prevsample >> 8;
            encode_buf[V_STREAM_OUTPUT_SOUND_LEN + 1] = encoder_adpcm.prevsample;
            encode_buf[V_STREAM_OUTPUT_SOUND_LEN + 2] = encoder_adpcm.previndex;
            ADPCMEncoderBuf2(mic_data_1ch, (char*)(encode_buf), &encoder_adpcm);
            //compressing end

            //decompressing
            decoder_adpcm.prevsample = ((int16_t)(encode_buf[V_STREAM_OUTPUT_SOUND_LEN]) << 8) |
                    (int16_t)(encode_buf[V_STREAM_OUTPUT_SOUND_LEN + 1]);

            decoder_adpcm.previndex = ((int32_t)(encode_buf[V_STREAM_OUTPUT_SOUND_LEN + 2]));
            ADPCMDecoderBuf2((char*)(encode_buf), mic_data_1ch, &decoder_adpcm);
            //decompressing end
            ///////////////////////////////////////////////////////////////////////////////////////
*/

            bufferRequest.buffersRequested = I2SCC26XX_BUFFER_OUT;
            I2SCC26XX_requestBuffer(i2sHandle, &bufferRequest);
            if (gotBufferOut)
            {
                memcpy(bufferRequest.bufferOut, mic_data_1ch, sizeof(mic_data_1ch));
                //memset(bufferRequest.bufferOut, 0x53, sizeof(mic_data_1ch));
                bufferRelease.bufferHandleIn = NULL;
                bufferRelease.bufferHandleOut = bufferRequest.bufferHandleOut;
                I2SCC26XX_releaseBuffer(i2sHandle, &bufferRelease);
                gotBufferOut = 0;
                i2c_read_delay++;
            }

//            bufferRequest.buffersRequested = I2SCC26XX_BUFFER_IN_AND_OUT;
//            I2SCC26XX_requestBuffer(i2sHandle, &bufferRequest);
//            if (gotBufferInOut)
//            {
//                //memcpy(bufferRequest.bufferOut, raw_data_send, sizeof(raw_data_send));
//                memcpy(mic_data_1ch, bufferRequest.bufferIn, sizeof(mic_data_1ch));
//                memcpy(bufferRequest.bufferOut, mic_data_1ch, sizeof(mic_data_1ch));
//
//                bufferRelease.bufferHandleOut = bufferRequest.bufferHandleOut;
//                bufferRelease.bufferHandleIn = bufferRequest.bufferHandleIn;
//                I2SCC26XX_releaseBuffer(i2sHandle, &bufferRelease);
//                gotBufferInOut = 0;
//                i2c_read_delay++;
//            }


        break;

        case APP_MSG_Buttons:
            button_processing();
        break;
        case APP_MSG_I2C_Read_Status:
            max9860_I2C_Read_Status();
        break;

        case APP_MSG_Read_key:
            get_fh_key();
        break;

        case APP_MSG_Write_key:
            send_fh_key();
        break;

        case APP_MSG_Load_vol:
            uint8_t status = 0;
            status = osal_snv_read(INIT_VOL_ADDR, 1, &current_volume);
                if(status != SUCCESS)
                {
                    current_volume = INIT_GAIN;
                }
                button_processing();
        break;

        case APP_MSG_Write_vol:
            osal_snv_write(INIT_VOL_ADDR, 1, &current_volume);
        break;

        case APP_MSG_Read_ADC_Voltage:
            if (ADCBuf_convert(adc_hdl, &adc_conversion, 1) != ADCBuf_STATUS_SUCCESS) {
                while(1);
            }
        break;

        case APP_MSG_Decrypt_packet:
            mailpost_usage = Mailbox_getNumPendingMsgs(mailbox);
            if(mailpost_usage>0){
                Mailbox_pend(mailbox, packet_data, BIOS_NO_WAIT);
                decrypt_packet(packet_data);
                decoder_adpcm.prevsample = ((int16_t)(packet_data[V_STREAM_OUTPUT_SOUND_LEN]) << 8) |
                        (int16_t)(packet_data[V_STREAM_OUTPUT_SOUND_LEN + 1]);

                decoder_adpcm.previndex = ((int32_t)(packet_data[V_STREAM_OUTPUT_SOUND_LEN + 2]));

#ifdef DOUBLE_DATA_RATE

                uint8_t j =0;
                ADPCMDecoderBuf2((char*)(packet_data), extrapolate_buf, &decoder_adpcm);
                for(uint8_t i = 0 ; i < I2S_SAMP_PER_FRAME ; i+=2)
                {
                    raw_data_send[i] = extrapolate_buf[i/2];
                }
                for(uint8_t i = 1 ; i < I2S_SAMP_PER_FRAME; i+=2)
                {
                    if(i == I2S_SAMP_PER_FRAME-1){
                        raw_data_send[i] = extrapolate_buf[j];
                    }
                    else
                    {
                        raw_data_send[i] = (extrapolate_buf[j]+extrapolate_buf[j+1])/2;
                    }
                    j++;
                }
#else
                ADPCMDecoderBuf2((char*)(packet_data), raw_data_send, &decoder_adpcm);
#endif
                channel_power = 0;
                for(uint8_t i = 0 ; i < I2S_SAMP_PER_FRAME ; i++)
                {
                    channel_power += (uint64_t)((int32_t)raw_data_send[i] * (int32_t)raw_data_send[i]);
                }
                channel_power = channel_power/I2S_SAMP_PER_FRAME;

                if (channel_power > NOISE_POWER)
                {
                    sound_appeared = true;
                    sound_timestamp = SOUND_DELAY;
                }

                if(sound_timestamp> 0 )
                {
                    sound_timestamp--;
                }
                else
                {
                    sound_appeared = false;
                    memset(raw_data_send, 0, sizeof(raw_data_send));
                }

            }else{
                memset ( packet_data,   0, sizeof(packet_data) );
                memset ( raw_data_send, 0, sizeof(raw_data_send));
            }

            break;
    }
}


static void bufRdy_callback(I2SCC26XX_Handle handle, I2SCC26XX_StreamNotification *pStreamNotification)
{
    I2SCC26XX_Status streamStatus = pStreamNotification->status;

    if (streamStatus == I2SCC26XX_STREAM_BUFFER_READY || streamStatus == I2SCC26XX_STREAM_BUFFER_READY_BUT_NO_AVAILABLE_BUFFERS)
    {
        gotBufferOut = true;
        gotBufferIn = true;
        gotBufferInOut = true;

    }
}
/******************************************************************************
 *****************************************************************************
 *
 *  Handlers of system/application events deferred to the user Task context.
 *  Invoked from the application Task function above.
 *
 *  Further down you can find the callback handler section containing the
 *  functions that defer their actions via messages to the application task.
 *
 ****************************************************************************
 *****************************************************************************/


/*
 * @brief   Process a pending GAP Role state change event.
 *
 * @param   newState - new state
 *
 * @return  None.
 */
static void user_processGapStateChangeEvt(gaprole_States_t newState)
{
  switch ( newState )
  {
    case GAPROLE_STARTED:
      {
        uint8_t ownAddress[B_ADDR_LEN];
        uint8_t systemId[DEVINFO_SYSTEM_ID_LEN];

        GAPRole_GetParameter(GAPROLE_BD_ADDR, ownAddress);

        // use 6 bytes of device address for 8 bytes of system ID value
        systemId[0] = ownAddress[0];
        systemId[1] = ownAddress[1];
        systemId[2] = ownAddress[2];

        // set middle bytes to zero
        systemId[4] = 0x00;
        systemId[3] = 0x00;

        // shift three bytes up
        systemId[7] = ownAddress[5];
        systemId[6] = ownAddress[4];
        systemId[5] = ownAddress[3];

        DevInfo_SetParameter(DEVINFO_SYSTEM_ID, DEVINFO_SYSTEM_ID_LEN, systemId);

        // Display device address
        char *cstr_ownAddress = Util_convertBdAddr2Str(ownAddress);
      }
      break;

    case GAPROLE_ADVERTISING:
      break;

    case GAPROLE_CONNECTED:
      {
        uint8_t peerAddress[B_ADDR_LEN];

        GAPRole_GetParameter(GAPROLE_CONN_BD_ADDR, peerAddress);

        char *cstr_peerAddress = Util_convertBdAddr2Str(peerAddress);
       }
      break;

    case GAPROLE_CONNECTED_ADV:
      break;

    case GAPROLE_WAITING:

      // Turn off periodic clocks for ind/noti demo
      //stop_voice_handle();
      break;

    case GAPROLE_WAITING_AFTER_TIMEOUT:

      // Turn off periodic clocks for ind/noti demo
     // stop_voice_handle();
      break;

    case GAPROLE_ERROR:
      break;

    default:
      break;
  }
}




/*
 * @brief   Handle a write request sent from a peer device.
 *
 *          Invoked by the Task based on a message received from a callback.
 *
 *          When we get here, the request has already been accepted by the
 *          service and is valid from a BLE protocol perspective as well as
 *          having the correct length as defined in the service implementation.
 *
 * @param   pCharData  pointer to malloc'd char write data
 *
 * @return  None.
 */
void user_Vogatt_ValueChangeHandler(char_data_t *pCharData)
{
  static uint8_t pretty_data_holder[16]; // 5 bytes as hex string "AA:BB:CC:DD:EE"
  Util_convertArrayToHexString(pCharData->data, pCharData->dataLen,
                               pretty_data_holder, sizeof(pretty_data_holder));

  switch (pCharData->paramID)
  {
    case V_STREAM_START_ID:
      // Do something useful with pCharData->data here

      // -------------------------
      break;

    case V_STREAM_INPUT_ID:  //rx data here!!!
      // Do something useful with pCharData->data here
      Mailbox_post(mailbox, pCharData->data, BIOS_NO_WAIT);

      // -------------------------
      break;

  default:
    return;
  }
}

/*
 * @brief   Handle a CCCD (configuration change) write received from a peer
 *          device. This tells us whether the peer device wants us to send
 *          Notifications or Indications.
 *
 * @param   pCharData  pointer to malloc'd char write data
 *
 * @return  None.
 */
void user_Vogatt_CfgChangeHandler(char_data_t *pCharData)
{
  // Cast received data to uint16, as that's the format for CCCD writes.
  uint16_t configValue = *(uint16_t *)pCharData->data;
  char *configValString;

  // Determine what to tell the user
  switch(configValue)
  {
  case GATT_CFG_NO_OPERATION:
    configValString = "Noti/Ind disabled";
    break;
  case GATT_CLIENT_CFG_NOTIFY:
    configValString = "Notifications enabled";
    break;
  case GATT_CLIENT_CFG_INDICATE:
    configValString = "Indications enabled";
    break;
  }

  /* Enable notification */
  switch (pCharData->paramID)
  {
    case V_STREAM_OUTPUT_ID:
      // -------------------------
      // Do something useful with configValue here. It tells you whether someone
      // wants to know the state of this characteristic.
      // ... In the generated example we turn periodic clocks on/off
      if (configValue) // 0x0001 and 0x0002 both indicate turned on.
      {
          if(stream_on != 1){
              GAPRole_SendUpdateParam(8, 8, 0, TIMEOUT, GAPROLE_RESEND_PARAM_UPDATE);
              start_voice_handle();
          }
      }
      else
      {
          //stop_voice_handle();
      }
      break;

  default:
    return;
  }
}


/*
 * @brief   Process an incoming BLE stack message.
 *
 *          This could be a GATT message from a peer device like acknowledgement
 *          of an Indication we sent, or it could be a response from the stack
 *          to an HCI message that the user application sent.
 *
 * @param   pMsg - message to process
 *
 * @return  TRUE if safe to deallocate incoming message, FALSE otherwise.
 */
static uint8_t ProjectZero_processStackMsg(ICall_Hdr *pMsg)
{
  uint8_t safeToDealloc = TRUE;

  switch (pMsg->event)
  {
    case GATT_MSG_EVENT:
      // Process GATT message
      safeToDealloc = ProjectZero_processGATTMsg((gattMsgEvent_t *)pMsg);
      break;

    case HCI_GAP_EVENT_EVENT:
      {
        // Process HCI message
        switch(pMsg->status)
        {
          case HCI_COMMAND_COMPLETE_EVENT_CODE:
            // Process HCI Command Complete Event
            break;

          default:
            break;
        }
      }
      break;

    default:
      // do nothing
      break;
  }

  return (safeToDealloc);
}


/*
 * @brief   Process GATT messages and events.
 *
 * @return  TRUE if safe to deallocate incoming message, FALSE otherwise.
 */
static uint8_t ProjectZero_processGATTMsg(gattMsgEvent_t *pMsg)
{
  // See if GATT server was unable to transmit an ATT response
  if (pMsg->hdr.status == blePending)
  {

    // No HCI buffer was available. Let's try to retransmit the response
    // on the next connection event.
    if (HCI_EXT_ConnEventNoticeCmd(pMsg->connHandle, selfEntity,
                                   PRZ_CONN_EVT_END_EVT) == SUCCESS)
    {
      // First free any pending response
      ProjectZero_freeAttRsp(FAILURE);

      // Hold on to the response message for retransmission
      pAttRsp = pMsg;

      // Don't free the response message yet
      return (FALSE);
    }
  }
  else if (pMsg->method == ATT_FLOW_CTRL_VIOLATED_EVENT)
  {
    // ATT request-response or indication-confirmation flow control is
    // violated. All subsequent ATT requests or indications will be dropped.
    // The app is informed in case it wants to drop the connection.

  }
  else if (pMsg->method == ATT_MTU_UPDATED_EVENT)
  {
    // MTU size updated
  }
  else
  {
    // Got an expected GATT message from a peer.
  }

  // Free message payload. Needed only for ATT Protocol messages
  GATT_bm_free(&pMsg->msg, pMsg->method);

  // It's safe to free the incoming message
  return (TRUE);
}




/*
 *  Application error handling functions
 *****************************************************************************/

/*
 * @brief   Send a pending ATT response message.
 *
 *          The message is one that the stack was trying to send based on a
 *          peer request, but the response couldn't be sent because the
 *          user application had filled the TX queue with other data.
 *
 * @param   none
 *
 * @return  none
 */
static void ProjectZero_sendAttRsp(void)
{
  // See if there's a pending ATT Response to be transmitted
  if (pAttRsp != NULL)
  {
    uint8_t status;

    // Increment retransmission count
    rspTxRetry++;

    // Try to retransmit ATT response till either we're successful or
    // the ATT Client times out (after 30s) and drops the connection.
    status = GATT_SendRsp(pAttRsp->connHandle, pAttRsp->method, &(pAttRsp->msg));
    if ((status != blePending) && (status != MSG_BUFFER_NOT_AVAIL))
    {
      // Disable connection event end notice
      HCI_EXT_ConnEventNoticeCmd(pAttRsp->connHandle, selfEntity, 0);

      // We're done with the response message
      ProjectZero_freeAttRsp(status);
    }
    else
    {
      // Continue retrying
    }
  }
}

/*
 * @brief   Free ATT response message.
 *
 * @param   status - response transmit status
 *
 * @return  none
 */
static void ProjectZero_freeAttRsp(uint8_t status)
{
  // See if there's a pending ATT response message
  if (pAttRsp != NULL)
  {
    // See if the response was sent out successfully
    if (status == SUCCESS)
    {
    }
    else
    {
       // Free response payload
      GATT_bm_free(&pAttRsp->msg, pAttRsp->method);
    }

    // Free response message
    ICall_freeMsg(pAttRsp);

    // Reset our globals
    pAttRsp = NULL;
    rspTxRetry = 0;
  }
}


/******************************************************************************
 *****************************************************************************
 *
 *  Handlers of direct system callbacks.
 *
 *  Typically enqueue the information or request as a message for the
 *  application Task for handling.
 *
 ****************************************************************************
 *****************************************************************************/


/*
 *  Callbacks from the Stack Task context (GAP or Service changes)
 *****************************************************************************/

/**
 * Callback from GAP Role indicating a role state change.
 */
static void user_gapStateChangeCB(gaprole_States_t newState)
{
  user_enqueueRawAppMsg( APP_MSG_GAP_STATE_CHANGE, (uint8_t *)&newState, sizeof(newState) );
}

/*
 * @brief   Passcode callback.
 *
 * @param   connHandle - connection handle
 * @param   uiInputs   - input passcode?
 * @param   uiOutputs  - display passcode?
 * @param   numComparison - numeric comparison value
 *
 * @return  none
 */
static void user_gapBondMgr_passcodeCB(uint8_t *deviceAddr, uint16_t connHandle,
                                       uint8_t uiInputs, uint8_t uiOutputs, uint32 numComparison)
{
  passcode_req_t req =
  {
    .connHandle = connHandle,
    .uiInputs = uiInputs,
    .uiOutputs = uiOutputs,
    .numComparison = numComparison
  };

  // Defer handling of the passcode request to the application, in case
  // user input is required, and because a BLE API must be used from Task.
  user_enqueueRawAppMsg(APP_MSG_SEND_PASSCODE, (uint8_t *)&req, sizeof(req));
}

/*
 * @brief   Pairing state callback.
 *
 * @param   connHandle - connection handle
 * @param   state      - pairing state
 * @param   status     - pairing status
 *
 * @return  none
 */
static void user_gapBondMgr_pairStateCB(uint16_t connHandle, uint8_t state,
                                        uint8_t status)
{
  if (state == GAPBOND_PAIRING_STATE_STARTED)
  {
  }
  else if (state == GAPBOND_PAIRING_STATE_COMPLETE)
  {
    if (status == SUCCESS)
    {
    }
    else
    {
    }
  }
  else if (state == GAPBOND_PAIRING_STATE_BONDED)
  {
    if (status == SUCCESS)
    {
    }
  }
}

/**
 * Callback handler for characteristic value changes in services.
 */
static void user_service_ValueChangeCB( uint16_t connHandle, uint16_t svcUuid,
                                        uint8_t paramID, uint8_t *pValue,
                                        uint16_t len )
{
  // See the service header file to compare paramID with characteristic.
  user_enqueueCharDataMsg(APP_MSG_SERVICE_WRITE, connHandle, svcUuid, paramID,
                          pValue, len);
}

/**
 * Callback handler for characteristic configuration changes in services.
 */
static void user_service_CfgChangeCB( uint16_t connHandle, uint16_t svcUuid,
                                      uint8_t paramID, uint8_t *pValue,
                                      uint16_t len )
{
  user_enqueueCharDataMsg(APP_MSG_SERVICE_CFG, connHandle, svcUuid,
                          paramID, pValue, len);
}

/*
 *  Callbacks from Swi-context
 *****************************************************************************/

/*
 *  Callbacks from Hwi-context
 *****************************************************************************/


/******************************************************************************
 *****************************************************************************
 *
 *  Utility functions
 *
 ****************************************************************************
 *****************************************************************************/

/*
 * @brief  Generic message constructor for characteristic data.
 *
 *         Sends a message to the application for handling in Task context where
 *         the message payload is a char_data_t struct.
 *
 *         From service callbacks the appMsgType is APP_MSG_SERVICE_WRITE or
 *         APP_MSG_SERVICE_CFG, and functions running in another context than
 *         the Task itself, can set the type to APP_MSG_UPDATE_CHARVAL to
 *         make the user Task loop invoke user_updateCharVal function for them.
 *
 * @param  appMsgType    Enumerated type of message being sent.
 * @param  connHandle    GAP Connection handle of the relevant connection
 * @param  serviceUUID   16-bit part of the relevant service UUID
 * @param  paramID       Index of the characteristic in the service
 * @oaram  *pValue       Pointer to characteristic value
 * @param  len           Length of characteristic data
 */
static void user_enqueueCharDataMsg( app_msg_types_t appMsgType,
                                     uint16_t connHandle,
                                     uint16_t serviceUUID, uint8_t paramID,
                                     uint8_t *pValue, uint16_t len )
{
  // Called in Stack's Task context, so can't do processing here.
  // Send message to application message queue about received data.
  uint16_t readLen = len; // How much data was written to the attribute

  // Allocate memory for the message.
  // Note: The pCharData message doesn't have to contain the data itself, as
  //       that's stored in a variable in the service implementation.
  //
  //       However, to prevent data loss if a new value is received before the
  //       service's container is read out via the GetParameter API is called,
  //       we copy the characteristic's data now.
  app_msg_t *pMsg = ICall_malloc( sizeof(app_msg_t) + sizeof(char_data_t) +
                                  readLen );

  if (pMsg != NULL)
  {
    pMsg->type = appMsgType;

    char_data_t *pCharData = (char_data_t *)pMsg->pdu;
    pCharData->svcUUID = serviceUUID; // Use 16-bit part of UUID.
    pCharData->paramID = paramID;
    // Copy data from service now.
    memcpy(pCharData->data, pValue, readLen);
    // Update pCharData with how much data we received.
    pCharData->dataLen = readLen;
    // Enqueue the message using pointer to queue node element.
    Queue_enqueue(hApplicationMsgQ, &pMsg->_elem);
  // Let application know there's a message.
  Event_post(syncEvent, PRZ_APP_MSG_EVT);
  }
}

/*
 * @brief  Generic message constructor for application messages.
 *
 *         Sends a message to the application for handling in Task context.
 *
 * @param  appMsgType    Enumerated type of message being sent.
 * @oaram  *pValue       Pointer to characteristic value
 * @param  len           Length of characteristic data
 */
void user_enqueueRawAppMsg(app_msg_types_t appMsgType, uint8_t *pData,
                                  uint16_t len)
{
  // Allocate memory for the message.
  app_msg_t *pMsg = ICall_malloc( sizeof(app_msg_t) + len );

  if (pMsg != NULL)
  {
    pMsg->type = appMsgType;

    // Copy data into message
    memcpy(pMsg->pdu, pData, len);

    // Enqueue the message using pointer to queue node element.

    Queue_enqueue(hApplicationMsgQ, &pMsg->_elem);
//    // Let application know there's a message.
    Event_post(syncEvent, PRZ_APP_MSG_EVT);
  }
}


/*
 * @brief  Convenience function for updating characteristic data via char_data_t
 *         structured message.
 *
 * @note   Must run in Task context in case BLE Stack APIs are invoked.
 *
 * @param  *pCharData  Pointer to struct with value to update.
 */
static void user_updateCharVal(char_data_t *pCharData)
{
  switch(pCharData->svcUUID)
  {
    case VOGATT_SERV_UUID:
      Vogatt_SetParameter( pCharData->paramID,
              pCharData->dataLen, pCharData->data );
    break;

  }
}

/*
 * @brief   Convert {0x01, 0x02} to "01:02"
 *
 * @param   src - source byte-array
 * @param   src_len - length of array
 * @param   dst - destination string-array
 * @param   dst_len - length of array
 *
 * @return  array as string
 */
static char *Util_convertArrayToHexString(uint8_t const *src, uint8_t src_len,
                                          uint8_t *dst, uint8_t dst_len)
{
  char        hex[] = "0123456789ABCDEF";
  uint8_t     *pStr = dst;
  uint8_t     avail = dst_len-1;

  memset(dst, 0, avail);

  while (src_len && avail > 3)
  {
    if (avail < dst_len-1) { *pStr++ = ':'; avail -= 1; };
    *pStr++ = hex[*src >> 4];
    *pStr++ = hex[*src++ & 0x0F];
    avail -= 2;
    src_len--;
  }

  if (src_len && avail)
    *pStr++ = ':'; // Indicate not all data fit on line.

  return (char *)dst;
}


//GPTimerCC26XX_Value system_tick = 0;
/* Functions for handle tx/rx packets of voice samples */


static void voice_hdl_init(void)
{
    //read_aes_key(&key);
    max9860_I2C_Init();

    GPTimerCC26XX_Params_init(&tim_params);
    tim_params.width = GPT_CONFIG_32BIT;
    tim_params.mode = GPT_MODE_PERIODIC_UP;
    tim_params.debugStallMode = GPTimerCC26XX_DEBUG_STALL_ON;
    blink_tim_hdl = GPTimerCC26XX_open(Board_GPTIMER2A, &tim_params);
    //system_time = GPTimerCC26XX_open(Board_GPTIMER1A, &tim_params);
    //GPTimerCC26XX_start(system_time);

    if (blink_tim_hdl == NULL) {
        while (1);
    }
    GPTimerCC26XX_setLoadValue(blink_tim_hdl, (GPTimerCC26XX_Value)LOW_STATE_TIME);
    GPTimerCC26XX_registerInterrupt(blink_tim_hdl, blink_timer_callback, GPT_INT_TIMEOUT);
    GPTimerCC26XX_start(blink_tim_hdl);

    tim_params.width = GPT_CONFIG_16BIT;
    samp_tim_hdl = GPTimerCC26XX_open(Board_GPTIMER3A, &tim_params);
    if (samp_tim_hdl == NULL) {
        while (1);
    }
    GPTimerCC26XX_setLoadValue(samp_tim_hdl, (GPTimerCC26XX_Value)(SAMP_TIME));
    GPTimerCC26XX_registerInterrupt(samp_tim_hdl, samp_timer_callback, GPT_INT_TIMEOUT);
    max9860_I2C_Shutdown_state(0);//disable shutdown_mode

    GPTimerCC26XX_start(samp_tim_hdl);

    buttonPinHandle = PIN_open(&buttonPinState, buttonPinTable);
    if(!buttonPinHandle) {
        /* Error initializing button pins */
        while(1);
    }

    if (PIN_registerIntCb(buttonPinHandle, &buttonCallbackFxn) != 0) {
         /* Error registering button callback function */
         while(1);
     }

    I2SCC26XX_init(i2sHandle);
    I2SCC26XX_Handle i2sHandleTmp = NULL;
    AudioDuplex_disableCache();

    i2sContMgtBuffer = (uint8_t *)(I2S_MEM_BASE + I2S_BUF + 1);
    audio_decoded = (int16_t *)I2S_MEM_BASE;
    // Setup I2S Params
    i2sParams.blockSize              = I2S_SAMP_PER_FRAME;
    i2sParams.pvContBuffer           = (void *) audio_decoded;
    i2sParams.pvContMgtBuffer        = (void *) i2sContMgtBuffer;
    i2sParams.ui32conMgtBufTotalSize =  I2S_BLOCK_OVERHEAD_IN_BYTES *  \
                                        I2SCC26XX_QUEUE_SIZE\
                                        * 2;

    i2sParams.ui32conBufTotalSize    =  sizeof(int16_t) * (I2S_SAMP_PER_FRAME * \
                                        I2SCC26XX_QUEUE_SIZE \
                                        * NUM_OF_CHANNELS);
    // Reset I2S handle and attempt to open
    i2sHandle = (I2SCC26XX_Handle)&(I2SCC26XX_config);
    i2sHandleTmp = I2SCC26XX_open(i2sHandle, &i2sParams);

    if(!i2sHandleTmp){//pdmHandle){
        while(1);
    }

    CryptoCC26XX_init();
    CryptoCC26XX_Params_init(&crypto_params);

    crypto_hdl = CryptoCC26XX_open(Board_CRYPTO0, false, &crypto_params);
    if (!crypto_hdl)
    {
        while(1);
    }

    AONBatMonEnable();

    /* ADC init */
    ADCBuf_init();

    ADCBuf_Params_init(&adc_params);
    adc_params.callbackFxn = adc_callback;
    adc_params.recurrenceMode = ADCBuf_RECURRENCE_MODE_ONE_SHOT;
    adc_params.returnMode = ADCBuf_RETURN_MODE_CALLBACK;
    adc_params.samplingFrequency = SAMPFREQ;
//
    adc_hdl = ADCBuf_open(Board_ADCBUF0, &adc_params);//Board_ADCBUF0
//
    adc_conversion.arg = NULL;
    adc_conversion.adcChannel = CC2640R2_LAUNCHXL_ADCBUF0CHANNEL5;
    adc_conversion.sampleBuffer = samp_buf1;
    adc_conversion.sampleBufferTwo = samp_buf2;
    adc_conversion.samplesRequestedCount = ADCBUFSIZE;
    if (!adc_hdl){
        while(1);
    }
    start_voice_handle();
    /* Start converting. */
}

static uint16_t countAdc = 0;

void adc_callback(ADCBuf_Handle handle, ADCBuf_Conversion *conversion,
    void *completedADCBuffer, uint32_t completedChannel) {
    countAdc++;
    int16_t *buf_ptr = (int16_t*)completedADCBuffer;
    /* handle receive data */
    for(uint32_t i = 0 ; i < ADCBUFSIZE; i++)
        adc_data[i] = buf_ptr[i] ;
   // ADCBuf_convertCancel(adc_hdl);
}







/*
*  ======== buttonCallbackFxn ========
*  Pin interrupt Callback function board buttons configured in the pinTable.
*  If Board_PIN_LED3 and Board_PIN_LED4 are defined, then we'll add them to the PIN
*  callback function.
*/



void buttonCallbackFxn(PIN_Handle handle, PIN_Id pinId) {

   //CPUdelay(8000*50);
   if (!PIN_getInputValue(pinId)) {
       /* Toggle LED based on the button pressed */
       switch (pinId) {
           case CC2640R2_LAUNCHXL_PIN_BTN1:
               buttonVol_UP_pressed = true;
               buttonVol_DOWN_pressed = false;
               break;

           case CC2640R2_LAUNCHXL_PIN_BTN2:
               buttonVol_UP_pressed = false;
               buttonVol_DOWN_pressed = true;
               break;

           default:
               buttonVol_UP_pressed = false;
               buttonVol_DOWN_pressed = false;
               /* Do nothing */
               break;
       }
   }
   user_enqueueRawAppMsg(APP_MSG_Buttons, &button_val, 1);

}


void button_processing(void){

    if(buttonVol_UP_pressed)
    {
        if(current_volume<=0)
        {
           current_volume = 0;
        }
        else
        {
           current_volume-=2;
        }
        buttonVol_UP_pressed = false;
    }
    else if(buttonVol_DOWN_pressed)
    {
        if(current_volume>=86) //188 - MUTE
        {
           current_volume = 86;
        }
        else
        {
           current_volume+=2;
        }
        buttonVol_DOWN_pressed = false;
    }
    else
    {
        buttonVol_UP_pressed = false;
        buttonVol_DOWN_pressed = false;
    }

    max9860_I2C_Volume_update(current_volume);

}


static void blink_timer_callback(GPTimerCC26XX_Handle handle, GPTimerCC26XX_IntMask interruptMask)
{
    static bool blink = false;
    static bool bat_low = false;

    if(blink)
    {
        blink = false;
        GPTimerCC26XX_setLoadValue(blink_tim_hdl, load_val[0]);

        if(!bat_low)
        {
            bat_low = get_bat_voltage() < BAT_LOW_VOLTAGE;
        }
        else
        {
            PIN_setOutputValue(ledPinHandle, Board_RLED, 0);
        }

        if(!stream_on)
        {
            PIN_setOutputValue(ledPinHandle, Board_GLED, 0);
        }
    }
    else
    {
        blink = true;
        GPTimerCC26XX_setLoadValue(blink_tim_hdl, load_val[1]);

        if(bat_low)
        {
            PIN_setOutputValue(ledPinHandle, Board_RLED, 1);
        }

        if(!stream_on)
        {
            PIN_setOutputValue(ledPinHandle, Board_GLED, 1);
        }
    }
}

static void samp_timer_callback(GPTimerCC26XX_Handle handle, GPTimerCC26XX_IntMask interruptMask)
{

//    if(stream_on){

//        user_enqueueRawAppMsg(APP_MSG_Decrypt_packet, &pdm_val, 1);
        user_enqueueRawAppMsg(APP_MSG_GET_VOICE_SAMP, &pdm_val, 1);
        timer_count++;
 //   }
}

static void start_voice_handle(void)
{
    max9860_I2C_Shutdown_state(0);//disable shutdown_mode
    //user_enqueueRawAppMsg(APP_MSG_Load_vol, &vol_val, 1); // read global vol level
    PIN_setOutputValue(ledPinHandle, Board_GLED, 1);
    //GPTimerCC26XX_start(samp_tim_hdl);
    I2SCC26XX_startStream(i2sHandle);
    //HCI_EXT_SetTxPowerCmd(HCI_EXT_TX_POWER_5_DBM);
    //HCI_EXT_SetRxGainCmd(LL_EXT_RX_GAIN_HIGH);
    stream_on = 1;
    packet_counter = 0;
}

static void stop_voice_handle(void)
{
    max9860_I2C_Shutdown_state(1);//enable shutdown_mode
    if(stream_on)
    {
        if(!I2SCC26XX_stopStream(i2sHandle)){
           while(1);
        }
        GPTimerCC26XX_stop(samp_tim_hdl);
    }

    PIN_setOutputValue(ledPinHandle, Board_GLED, 0);
    HCI_EXT_SetTxPowerCmd(HCI_EXT_TX_POWER_0_DBM);
    HCI_EXT_SetRxGainCmd(LL_EXT_RX_GAIN_STD);
    stream_on = 0;

    //clean buffers for quiet beginning of next stream
    while(mailpost_usage>0){
        Mailbox_pend(mailbox, packet_data, BIOS_NO_WAIT);
        mailpost_usage = Mailbox_getNumPendingMsgs(mailbox);
    }
    memset ( packet_data,   0, sizeof(packet_data) );
    memset ( raw_data_send, 0, sizeof(raw_data_send) );
    //memset ( &rtDW, 0, sizeof(rtDW) );

    user_enqueueRawAppMsg(APP_MSG_Write_vol, &vol_val, 1);
}

static void pdm_samp_hdl(void)
{
    uint8_t encode_buf[V_STREAM_OUTPUT_LEN];

    encode_buf[V_STREAM_OUTPUT_SOUND_LEN] = encoder_adpcm.prevsample >> 8;
    encode_buf[V_STREAM_OUTPUT_SOUND_LEN + 1] = encoder_adpcm.prevsample;
    encode_buf[V_STREAM_OUTPUT_SOUND_LEN + 2] = encoder_adpcm.previndex;

    //encode_buf[V_STREAM_OUTPUT_LEN - 4] = mailpost_usage;
    encode_buf[V_STREAM_OUTPUT_LEN - 4] = packet_counter >> 24;
    encode_buf[V_STREAM_OUTPUT_LEN - 3] = packet_counter >> 16;
    encode_buf[V_STREAM_OUTPUT_LEN - 2] = packet_counter >> 8;
    encode_buf[V_STREAM_OUTPUT_LEN - 1] = packet_counter;

    packet_counter++;
#ifdef DOUBLE_DATA_RATE
    ADPCMEncoderBuf2(temp_output, (char*)(encode_buf), &encoder_adpcm);
#else
    ADPCMEncoderBuf2(mic_data_1ch, (char*)(encode_buf), &encoder_adpcm);
#endif

    encrypt_packet(encode_buf);

    Vogatt_SetParameter(V_STREAM_OUTPUT_ID, V_STREAM_OUTPUT_LEN, encode_buf);
}

/*********************************************************************
 *********************************************************************/

/*********************************************************************
 * @fn      AudioDuplex_disableCache
 *
 * @brief   Disables the instruction cache and sets power constaints
 *          This prevents the device from sleeping while streaming
 *
 * @param   None.
 *
 * @return  None.
 */
static void AudioDuplex_disableCache()
{
    uint_least16_t hwiKey = Hwi_disable();
//    Power_setConstraint(PowerCC26XX_SB_VIMS_CACHE_RETAIN);
//    Power_setConstraint(PowerCC26XX_NEED_FLASH_IN_IDLE);
    VIMSModeSafeSet(VIMS_BASE, VIMS_MODE_DISABLED, true);
    Hwi_restore(hwiKey);
}

/*********************************************************************
 * @fn      AudioDuplex_enableCache
 *
 * @brief   Enables the instruction cache and releases power constaints
 *          Allows device to sleep again
 *
 * @param   None.
 *
 * @return  None.
 */
static void AudioDuplex_enableCache()
{
    uint_least16_t hwiKey = Hwi_disable();
    Power_releaseConstraint(PowerCC26XX_SB_VIMS_CACHE_RETAIN);
    Power_releaseConstraint(PowerCC26XX_NEED_FLASH_IN_IDLE);
    VIMSModeSafeSet(VIMS_BASE, VIMS_MODE_ENABLED, true);
    Hwi_restore(hwiKey);
}

static void encrypt_packet(uint8_t *packet)
{
    uint8_t tmp_packet[V_STREAM_OUTPUT_SOUND_LEN + 3];
    status = CryptoCC26XX_loadKey(crypto_hdl, key_index, (const uint32_t*)key);
    if(status != CRYPTOCC26XX_STATUS_SUCCESS)
    {
        while(1);
    }

    memcpy(tmp_packet, packet, V_STREAM_OUTPUT_SOUND_LEN + 3);

    CryptoCC26XX_Transac_init((CryptoCC26XX_Transaction *)&trans, CRYPTOCC26XX_OP_AES_ECB_ENCRYPT);
    trans.keyIndex = key_index;
    trans.msgIn = packet;
    trans.msgOut = tmp_packet;

    status = CryptoCC26XX_transact(crypto_hdl, (CryptoCC26XX_Transaction *) &trans);
    if(status != CRYPTOCC26XX_STATUS_SUCCESS)
    {
        while(1);
    }

    CryptoCC26XX_Transac_init((CryptoCC26XX_Transaction *)&trans, CRYPTOCC26XX_OP_AES_ECB_ENCRYPT);
    trans.keyIndex = key_index;
    trans.msgIn = &packet[16];
    trans.msgOut = &tmp_packet[16];

    status = CryptoCC26XX_transact(crypto_hdl, (CryptoCC26XX_Transaction *) &trans);
    if(status != CRYPTOCC26XX_STATUS_SUCCESS)
    {
        while(1);
    }

    memcpy(packet, tmp_packet, V_STREAM_OUTPUT_SOUND_LEN + 3);

    CryptoCC26XX_Transac_init((CryptoCC26XX_Transaction *)&trans, CRYPTOCC26XX_OP_AES_ECB_ENCRYPT);
    trans.keyIndex = key_index;
    trans.msgIn = &tmp_packet[27];
    trans.msgOut = &packet[27];

    status = CryptoCC26XX_transact(crypto_hdl, (CryptoCC26XX_Transaction *) &trans);
    if(status != CRYPTOCC26XX_STATUS_SUCCESS)
    {
        while(1);
    }
}

static void decrypt_packet(uint8_t *packet)
{
    //uint8_t tmp_packet[V_STREAM_INPUT_LEN - 4];
    uint8_t tmp_packet[V_STREAM_INPUT_SOUND_LEN + 3];
    status = CryptoCC26XX_loadKey(crypto_hdl, key_index, (const uint32_t*)key);
    if(status != CRYPTOCC26XX_STATUS_SUCCESS)
    {
        while(1);
    }

    memcpy(tmp_packet, packet, V_STREAM_OUTPUT_SOUND_LEN + 3);

    CryptoCC26XX_Transac_init((CryptoCC26XX_Transaction *)&trans, CRYPTOCC26XX_OP_AES_ECB_DECRYPT);
    trans.keyIndex = key_index;
    trans.msgIn = &packet[27];
    trans.msgOut = &tmp_packet[27];
    status = CryptoCC26XX_transact(crypto_hdl, (CryptoCC26XX_Transaction *) &trans);
    if(status != CRYPTOCC26XX_STATUS_SUCCESS)
    {
        while(1);
    }

    memcpy(packet, tmp_packet, V_STREAM_OUTPUT_SOUND_LEN + 3);

    CryptoCC26XX_Transac_init((CryptoCC26XX_Transaction *)&trans, CRYPTOCC26XX_OP_AES_ECB_DECRYPT);
    trans.keyIndex = key_index;
    trans.msgIn = &tmp_packet[16];
    trans.msgOut = &packet[16];
    status = CryptoCC26XX_transact(crypto_hdl, (CryptoCC26XX_Transaction *) &trans);
    if(status != CRYPTOCC26XX_STATUS_SUCCESS)
    {
        while(1);
    }

    CryptoCC26XX_Transac_init((CryptoCC26XX_Transaction *)&trans, CRYPTOCC26XX_OP_AES_ECB_DECRYPT);
    trans.keyIndex = key_index;
    trans.msgIn = tmp_packet;
    trans.msgOut = packet;
    status = CryptoCC26XX_transact(crypto_hdl, (CryptoCC26XX_Transaction *) &trans);
    if(status != CRYPTOCC26XX_STATUS_SUCCESS)
    {
        while(1);
    }
}

uint8_t read_aes_key(uint8_t *key)
{
    uint8_t status;
    static uint8_t default_key[] =
        {0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
        0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C};

    status = osal_snv_read(KEY_SNV_ID, KEY_SIZE, key);
    if(status != SUCCESS)
    {
        memcpy(key, default_key, KEY_SIZE);
    }

    return status;
}

uint8_t write_aes_key(uint8_t *key)
{
    return (osal_snv_write(KEY_SNV_ID, KEY_SIZE, key));
}

uint16_t get_bat_voltage(void)
{
    return ((AONBatMonBatteryVoltageGet() * 125) >> 5);
}
